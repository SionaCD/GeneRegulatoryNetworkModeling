# -*- coding: utf-8 -*-
"""Mock epithelium-2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PAzsg8FP403Sk-Pm3cYIXrDCsTu3-WU3
"""

#cd E:\Single cell\MOCK\filtered_feature_bc_matrix

from google.colab import drive
drive.mount('/content/drive')
import os
os.chdir("drive/My Drive/RNA_Velocity")

!pip install git+https://github.com/colomemaria/epiScanpy
!pip install velorama sklearn scanpy anndata

import numpy as np
import pandas as pd
import scanpy as sc
import pandas as pd

import anndata as ad

sc.settings.verbosity = 3             # verbosity: errors (0), warnings (1), info (2), hints (3)
sc.logging.print_header()
sc.settings.set_figure_params(dpi=80, facecolor='white')

adata = sc.read_mtx('matrix.mtx').T###T to switch name of obs with n.var

adata

###reading cell barcodes and gene names
genes=pd.read_csv('features.tsv',header=None)
barcodes=pd.read_csv('barcodes.tsv',sep='\t',header=None)

genes.head(3)

genes_=[]
for g in genes[0]:###clean the gene names and remove the unwanted charachters to get only the gene names
    genes_.append(g[19:][:-16])

adata.var["gene_id"] = genes_###add gene ID and barodes to the andata
adata.obs["cell_id"] = barcodes[[0]].values##add cell ID

adata.var

adata.obs_names=adata.obs['cell_id'].values.tolist() ##to convert obs_name from numbers (index) to cell barcod
adata.var_names=adata.var['gene_id'].values.tolist() ##to convert var_name from numbers (index) to gene ID

"""# Data Preprocessing

"""

#Show those genes that yield the highest fraction of counts in each single cell, across all cells.
sc.pl.highest_expr_genes(adata, n_top=20, )
##expecteded to see Malat1 it's mitochondrial gene, and other mitochondrial genes also usually it can detect ribosomal genes and actin

##filter out cells that has less that 200 genes and genes that expressed in less than 3 cells

sc.pp.filter_cells(adata, min_genes=200)
sc.pp.filter_genes(adata, min_cells=3)

adata.var['mt']=adata.var_names.str.startswith('mt-')##make new column with mitochondrial genes
adata.var

adata.var.mt.value_counts() ###Mitchondrial genes

sc.pp.calculate_qc_metrics(adata, qc_vars=['mt'], percent_top=None, log1p=False, inplace=True)
adata.var_names_make_unique()##to remove the duplicates in var_names

sc.pl.violin(adata, ['n_genes_by_counts', 'total_counts', 'pct_counts_mt'],
             jitter=0.4, multi_panel=True)

"""Remove cells that have too many mitochondrial genes expressed or too many total counts (to many total count might be douplets)"""

sc.pl.scatter(adata, x='total_counts', y='pct_counts_mt')
sc.pl.scatter(adata, x='total_counts', y='n_genes_by_counts')

##filtering by slicing andata
adata = adata[adata.obs.n_genes_by_counts < 8500, :]
adata = adata[adata.obs.pct_counts_mt < 15, :]

"""# Normalization"""

sc.pp.normalize_total(adata, target_sum=1e4)##library size correction

#Logarithmize the data , to avoid having zeros in our matrix
sc.pp.log1p(adata)

#Identify highly-variable genes.
sc.pp.highly_variable_genes(adata, min_mean=0.0125, max_mean=3, min_disp=0.5)

sc.pl.highly_variable_genes(adata)

adata.var.highly_variable.value_counts()

"""Set the .raw attribute of the AnnData object to the normalized and logarithmized raw gene expression for later use in differential testing and visualizations of gene expression. This simply freezes the state of the AnnData object."""

adata.raw = adata

adata = adata[:, adata.var.highly_variable]

sc.pp.regress_out(adata, 'total_counts')#Regress out effects of total counts per cell

##PCA
sc.pp.scale(adata, max_value=10)
sc.tl.pca(adata, svd_solver='arpack')

sc.pl.pca_variance_ratio(adata, log=True)

"""# Computing the neighborhood graph"""

sc.pp.neighbors(adata, n_neighbors=23, n_pcs=40)

#Embedding the neighborhood graph
sc.tl.leiden(adata)
sc.tl.paga(adata)

sc.tl.umap(adata)##use paga to imporve the conectivity between the clusters as umap encurage forming clusters which might shatter trajectories

##stem cells markers ,clu is not agreat markers for stem cells
sc.pl.umap(adata, color=['Lgr5', 'Smoc2', 'Clu','Sox4'])

##TA cells (trans-amplifying cell markers)
sc.pl.umap(adata, color=['Hmgn2', 'Ccna2', 'Mcm5'])

sc.pl.umap(adata, color=['Cdhr2', 'Tmem37', 'Fabp2','Slc26a3'])##enterocytes markers

sc.pl.umap(adata, color=['Muc2', 'Zg16', 'Atoh1','Reg4'])###goblet marker (secretory cells)

sc.pl.umap(adata, color=['Insm1', 'Pax6','Reg4'])##EEC marker secretory cells markers, Reg4 is a general secretory marker which can be present in Goblet and EEC

sc.pl.umap(adata, color=['Lyz1'])##it's for paneth cell markers, which not commonly present in colon cells, this result makes sense







sc.pl.umap(adata,color='leiden',legend_loc='on data')

##keep only epithelial cells
adata.obs['leiden']
adata_=adata[adata.obs['leiden'].isin(['5', '20', '2','3','1','12','13','18','23','21','14','19']),:]

sc.pl.umap(adata_,color='leiden',legend_loc='on data')



#Embedding the neighborhood graph##reclustering with leiden and resolution 0.2
sc.tl.leiden(adata_,resolution=0.2)
sc.tl.umap(adata_)
sc.pl.umap(adata_,color='leiden',legend_loc='on data')

##stem cells, Clu is not great makers, Sox4 can be in both stem cells and trans-amplifying cells
sc.pl.umap(adata_, color=['Lgr5', 'Smoc2', 'Clu','Sox4','Axin2','Kcne3'])##cluster

##TA cells,, trans-amplifying cells (near stem cells)
sc.pl.umap(adata_, color=['Hmgn2', 'Ccna2', 'Mcm5','Pcna','Hmgb2'])

sc.pl.umap(adata_, color=['Cdhr2', 'Tmem37', 'Fabp2','Slc26a3','Aqp8','Ndrg1'])##enterocytes, Slc26a3 is localized in the early enterocytes (enterocytes progenitors)

sc.pl.umap(adata_, color=['Muc2', 'Zg16', 'Atoh1','Reg4'])###goblet marker

sc.pl.umap(adata_, color=['Insm1', 'Pax6','Reg4'])##EEC marker
#Reg4 is a general secretory marker which can be present in Goblet and EEC

# create a dictionary to map cluster to annotation label
cluster2annotation = {
     '0': 'Stem cells',
     '1': 'TA',
     '2': 'TA2',
     '3': 'EC2',
     '4': 'GC2',
     '5': 'EC',
     '6': 'GC',
     '7': 'GC2',
     '8': 'Unknown',
     '9': 'EEc'
}

# add a new `.obs` column called `cell type` by mapping clusters to annotation using pandas `map` function
adata_.obs['cell type'] = adata_.obs['leiden'].map(cluster2annotation).astype('category')

sc.pl.umap(adata_,color='leiden',legend_loc='on data')

adata_.write_h5ad('adata.h5ad')

"""# RNA velocity"""

import scvelo as scv
scv.logging.print_version()

scv.settings.verbosity = 3  # show errors(0), warnings(1), info(2), hints(3)
scv.settings.presenter_view = True  # set max width size for presenter view
scv.set_figure_params('scvelo')  # for beautified visualization

Mock = scv.read('MOCK.loom', cache=True)##it has unspliced matrix

scv.utils.clean_obs_names(adata_)##you have to clean the obs.name to make the cell ID matching each other
scv.utils.clean_obs_names(Mock)

merged=scv.utils.merge(adata_, Mock)##merg with the preprocessed data
merged

scv.pl.proportions(merged)##20% of the RNA are unspliced

"""# Preprocess the Data"""

adata=merged.copy()
adata

scv.pp.filter_genes(adata, min_shared_counts=20)
scv.pp.normalize_per_cell(adata)
scv.pp.filter_genes_dispersion(adata, n_top_genes=5000)
scv.pp.log1p(adata)

# first and second order moments (means and uncentered variances) computed among nearest neighbors
scv.pp.filter_and_normalize(adata, min_shared_counts=20, n_top_genes=5000)
scv.pp.moments(adata, n_pcs=30, n_neighbors=30)

scv.pp.filter_and_normalize(adata, min_shared_counts=20, n_top_genes=5000)
scv.pp.moments(adata, n_pcs=30, n_neighbors=30)

"""# Estimate RNA velocity"""

##Dynamical Model to  learn the full transcriptional dynamics of splicing kinetics
scv.tl.recover_dynamics(adata)

##calculate RNA velocity
scv.tl.velocity(adata, mode='dynamical')
scv.tl.velocity_graph(adata)

adata.write('Mock.h5ad')

scv.pl.velocity_embedding_stream(adata, basis='umap',color='cell type')

scv.pl.velocity_embedding(adata, arrow_length=5, arrow_size=5, dpi=120,color='cell type')

scv.pl.velocity(adata, ['Muc2',  'Ndrg1', 'Lgr5'], ncols=2,color='cell type')
##Muc2 is for Goblet cells, Ndrg1 for differentiated cells enterocytes and secretory (goblet and EEC), Lgr5 for stem cells

"""The dynamical model recovers the latent time of the underlying cellular processes. This latent time represents the cellâ€™s internal clock and approximates the real time experienced by cells as they differentiate, based only on its transcriptional dynamics."""

scv.tl.latent_time(adata)
scv.pl.scatter(adata, color='latent_time', color_map='gnuplot', size=80)

"""# Identifying Cluster-specific top-likelihood genes (potenial driver)"""

scv.tl.rank_dynamical_genes(adata, groupby='cell type')
df_ = scv.get_df(adata, 'rank_dynamical_genes/names')

df_.to_csv('potenial driver.csv')

adata.layers['spliced']

adata.layers['unspliced']

df_.head(10)

scv.pl.velocity(adata, ['Cpe',  'Fcgbp', 'Hells'], ncols=2,color='cell type')

"""# calculate genes have cluster-specific differential velocity expression"""

scv.tl.rank_velocity_genes(adata, groupby='cell type', min_corr=.3)

df = scv.DataFrame(adata.uns['rank_velocity_genes']['names'])
df.head()

df.to_csv('cluster_differential_velocity.csv')

adata.write('adata.h5ad')

"""# cell rank

import cellrank as cr givers importerror
##ImportError: cannot import name 'Iterable' from 'collections' (C:\Users\ahmed\miniconda3\envs\my_project\lib\collections\__init__.py)
"""

##this solve the error

import collections.abc
#cell rank needs the four following aliases to be done manually.
collections.Iterable = collections.abc.Iterable
collections.Mapping = collections.abc.Mapping
collections.MutableSet = collections.abc.MutableSet
collections.MutableMapping = collections.abc.MutableMapping

import cellrank as cr

adata=sc.read_h5ad('adata.h5ad')
adata

"""the directional information comes from RNA velocity, and it use this information to compute initial & terminal states as well as fate probabilities for the dynamical process"""

adata.obs

#x=adata.obs['cell type'][(adata.obs['cell type']!='Stem cells') & (adata.obs['cell type']!='Unknown')]
#adata.obs['terminals']=x

#Identify terminal states
terminals=['EC2','EEc','GC']
cr.tl.terminal_states(adata, cluster_key='cell type')

##plot the terminal state
cr.pl.terminal_states(adata)

#Identify initial_state
cr.tl.initial_states(adata, cluster_key="cell type")

##plot the initial_state
cr.pl.initial_states(adata,discrete=True)

"""# Compute fate maps
Once we know the terminal states, we can compute associated fate maps - for each cell, we ask how likely is the cell to develop towards each of the identified terminal states.
"""

cr.tl.lineages(adata)##calculate cell to cell transition probabilties
cr.pl.lineages(adata, same_plot=False)

cr.pl.lineages(adata, same_plot=True)

adata

adata.obsm['to_terminal_states']

"""# Velorama"""

target_genes = pd.read_csv("potenial driver.csv")
print(target_genes.head())
print(target_genes.shape)

adata.var_names

# We need to choose a set of potential regulator genes; for now we will use ALL genes as potential regulators.
target_genes = target_genes.head(10) # use the top 10 potential drivers
regulator_genes = adata.var_names # all genes = potential regulators for now
adata.var['is_reg'] = [n in regulator_genes for n in adata.var.index.values]
adata.var['is_target'] = [n in target_genes for n in adata.var.index.values]

# Run velorama
!velorama -ds $adata.h5ad -dyn $rna_velocity -dev $cuda -l $L -hd $32 -rd $RNA_Velocity

